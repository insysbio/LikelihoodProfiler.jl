var documenterSearchIndex = {"docs":
[{"location":"profile_methods/#profile_likelihood_methods","page":"Profile likelihood methods","title":"Profile Likelihood Methods","text":"LikelihoodProfiler provides a range of methods to profile likelihood functions and explore practical identifiability. The method should be provided as the second argument to the solve function.","category":"section"},{"location":"profile_methods/#optimization_based_profiles","page":"Profile likelihood methods","title":"Optimization-based profiles","text":"The method computes profiles for each parameter by iteratively changing the value of the parameter and re-optimizing the likelihood function with respect to all other parameters. ","category":"section"},{"location":"profile_methods/#integration_based_profiles","page":"Profile likelihood methods","title":"Integration-based profiles","text":"The method computes profiles for each parameter (or function of parameters) by integrating the differential equations system. \n\nReferences:\n\nChen, J.-S. & Jennrich, R. I. Simple Accurate Approximation of Likelihood Profiles. Journal of Computational and Graphical Statistics 11, 714–732 (2002).\nChen, J.-S. & Jennrich, R. I. The Signed Root Deviance Profile and Confidence Intervals in Maximum Likelihood Analysis. Journal of the American Statistical Association 91, 993–998 (1996).","category":"section"},{"location":"profile_methods/#cico_profiles","page":"Profile likelihood methods","title":"Confidence Intervals by Constrained Optimization (CICO)","text":"The method computes intersections (endpoints of the confidence interval (CI)) of the profile with the predefined confidence level (threshold) without restoring the exact trajectory of the profile. Requires using CICOBase package.\n\nReferences:\n\nBorisov, I. & Metelkin, E. Confidence intervals by constrained optimization—An algorithm and software package for practical identifiability analysis in systems biology. PLoS Comput Biol 16, e1008495 (2020).\nVenzon, D. J. & Moolgavkar, S. H. A Method for Computing Profile-Likelihood-Based Confidence Intervals. Applied Statistics 37, 87 (1988).","category":"section"},{"location":"profile_methods/#LikelihoodProfiler.OptimizationProfiler-profile_methods","page":"Profile likelihood methods","title":"LikelihoodProfiler.OptimizationProfiler","text":"OptimizationProfiler{S, opType, optsType}\n\nA profiler method that uses stepwise re-optimization to profile the likelihood function.\n\nFields\n\nstepper::S: The algorithm used to compute the next profile point. Supported steppers include:\nFixedStep: Proposes a constant step size in the profiling direction (Default). \nLineSearchStep: Uses a line search to adaptively determine the step size in the direction which is chosen by the direction keyword argument.\noptimizer::opType: The optimizer used for the optimization process.\noptimizer_opts::optsType: Options for the optimizer. Defaults to NamedTuple().\n\nStepping Options\n\nThe stepper argument controls how the next profile point is chosen. For example:\n\nstepper = FixedStep(initial_step=0.1): Use a constant step size of 0.1.\nstepper = LineSearchStep(direction=:Secant, linesearch=InterpolationLineSearch()): Use a line search with secant direction.\n\nSee the documentation for each stepper type (e.g., ?FixedStep, ?LineSearchStep) for more details and customization options.\n\nExample\n\nusing OptimizationLBFGSB\nprofiler = OptimizationProfiler(; optimizer = LBFGSB(), optimizer_opts = (reltol=1e-4,))\n\n\n\n\n\n","category":"type"},{"location":"profile_methods/#LikelihoodProfiler.IntegrationProfiler-profile_methods","page":"Profile likelihood methods","title":"LikelihoodProfiler.IntegrationProfiler","text":"IntegrationProfiler{opType, optsType, DEAlg, DEOpts}\n\nA profiler method that uses integration of differential equations system to profile the likelihood function.\n\nFields\n\nreoptimize::Bool: Indicates whether to re-optimization after each step of the integrator. Defaults to false.\noptimizer::opType: The optimizer used for the optimization process. Defaults to nothing.\noptimizer_opts::optsType: Options for the optimizer. Defaults to NamedTuple().\nintegrator::DEAlg: The differential equation algorithm used for integration.\nintegrator_opts::DEOpts: Options for the differential equation solver. Defaults to NamedTuple().\nmatrix_type::Symbol: The type of matrix to be used for the Hessian approximation. Possible options are: :hessian, :identity. Defaults to :hessian.\ngamma::Float64: Correction factor used in integration if full hessian is not computed (e.g. matrix_type = :identity). Defaults to 1.0.\n\nExample\n\nusing OrdinaryDiffEq\nprofiler = IntegrationProfiler(integrator = Tsit5(), integrator_opts = (dtmax=0.3,), matrix_type = :hessian)\n\n\n\n\n\n","category":"type"},{"location":"profile_methods/#LikelihoodProfiler.CICOProfiler-profile_methods","page":"Profile likelihood methods","title":"LikelihoodProfiler.CICOProfiler","text":"CICOProfiler\n\nConfidence Intervals by Constrained Optimization (CICO) method to find the intersections of the likelihood function with the threshold. See CICOBase docs for more details. Requires using CICOBase.\n\nFields\n\noptimizer::Symbol: The optimizer used for the optimization process. Defaults to NLopt :LN_NELDERMEAD.\nscan_tol::Float64: The tolerance for the endpoints scan. Defaults to 1e-3.\n\nExample\n\nprofiler = CICOProfiler(optimizer = :LN_NELDERMEAD, scan_tol = 1e-3)\n\n\n\n\n\n","category":"type"},{"location":"api/#API-references","page":"API","title":"API references","text":"The package exports the following functions for parameters and functions identifiability analysis, confidence intervals evaluation and results visualization.","category":"section"},{"location":"api/#CommonSolve.solve-Tuple{ProfileLikelihoodProblem, LikelihoodProfiler.AbstractProfilerMethod}","page":"API","title":"CommonSolve.solve","text":"solve(plprob::ProfileLikelihoodProblem, method::AbstractProfilerMethod; \n        parallel_type::Symbol=:none, maxiters::Int=1e4, verbose::Bool=false)\n\nProfiles the likelihood function for the given problem plprob using the specified profiling method.\n\nArguments\n\nplprob::ProfileLikelihoodProblem: The profiling problem instance containing the parameters and likelihood function to be profiled.\nmethod::AbstractProfilerMethod: The method to be used for profiling.\nreoptimize_init::Bool=false: If true, re-optimizes the model at the provided initial parameter values optpars before profiling. Defaults to false.\nparallel_type::Symbol: Specifies the type of parallelism to be used. Supported values: :none, :threads, :distributed. Defaults to :none.\nmaxiters::Int: Maximum number of iterations for one branch (left and right) of the profiling process. Defaults to 1e4.\nverbose::Bool: Indicates whether to display the progress of the profiling process. Defaults to false.\n\nReturns\n\nReturns the profiling results ProfileLikelihoodSolution.\n\nExample\n\nplprob = ProfileLikelihoodProblem(optprob, optpars; idxs=1, profile_lower=-10., profile_upper=10.)\nmethod = OptimizationProfiler(optimizer = LBFGSB(), stepper = FixedStep())\nsol = solve(plprob, method)\n\n\n\n\n\n","category":"method"},{"location":"api/#LikelihoodProfiler.chi2_quantile","page":"API","title":"LikelihoodProfiler.chi2_quantile","text":"chi2_quantile(α, df=1)\n\nComputes α quantile for Chi2 distribution with df degrees of freedom\n\n\n\n\n\n","category":"function"},{"location":"api/#LikelihoodProfiler.CICOProfiler","page":"API","title":"LikelihoodProfiler.CICOProfiler","text":"CICOProfiler\n\nConfidence Intervals by Constrained Optimization (CICO) method to find the intersections of the likelihood function with the threshold. See CICOBase docs for more details. Requires using CICOBase.\n\nFields\n\noptimizer::Symbol: The optimizer used for the optimization process. Defaults to NLopt :LN_NELDERMEAD.\nscan_tol::Float64: The tolerance for the endpoints scan. Defaults to 1e-3.\n\nExample\n\nprofiler = CICOProfiler(optimizer = :LN_NELDERMEAD, scan_tol = 1e-3)\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.FixedStep","page":"API","title":"LikelihoodProfiler.FixedStep","text":"FixedStep{S}\n\nProfiler stepper that always proposes a fixed step size in the profiling direction.\n\nConstructors\n\nFixedStep(;initial_step=DEFAULT_INIT_STEP)\n\nKeyword arguments\n\ninitial_step=DEFAULT_INIT_STEP: The initial (and constant) step size to use for each profile step. This can be a number (for a constant step size) or a function (pars, idx) -> step for custom logic depending on the current parameters and index. If a number is provided, it is automatically wrapped as a function.\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.FunctionTarget","page":"API","title":"LikelihoodProfiler.FunctionTarget","text":"FunctionTarget{F,B}\n\nProfile target representing profiling of functions of model parameters.\n\nFields\n\nfs::AbstractVector{<:OptimizationFunction}: Functions of the parameters being profiled.\nprofile_lower::AbstractVector{<:Real}: Lower bounds for the profile likelihood. \nprofile_upper::AbstractVector{<:Real}: Upper bounds for the profile likelihood. \n\nProfile bounds profile_lower and profile_upper should be vectors of finite numerical values. \n\nConstructors\n\nCreate a target with explicit lower and upper bounds for each function of parameters.\n\nFunctionTarget(; fs::AbstractVector{<:OptimizationFunction}, profile_lower::AbstractVector{<:Real}, profile_upper::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.IntegrationProfiler","page":"API","title":"LikelihoodProfiler.IntegrationProfiler","text":"IntegrationProfiler{opType, optsType, DEAlg, DEOpts}\n\nA profiler method that uses integration of differential equations system to profile the likelihood function.\n\nFields\n\nreoptimize::Bool: Indicates whether to re-optimization after each step of the integrator. Defaults to false.\noptimizer::opType: The optimizer used for the optimization process. Defaults to nothing.\noptimizer_opts::optsType: Options for the optimizer. Defaults to NamedTuple().\nintegrator::DEAlg: The differential equation algorithm used for integration.\nintegrator_opts::DEOpts: Options for the differential equation solver. Defaults to NamedTuple().\nmatrix_type::Symbol: The type of matrix to be used for the Hessian approximation. Possible options are: :hessian, :identity. Defaults to :hessian.\ngamma::Float64: Correction factor used in integration if full hessian is not computed (e.g. matrix_type = :identity). Defaults to 1.0.\n\nExample\n\nusing OrdinaryDiffEq\nprofiler = IntegrationProfiler(integrator = Tsit5(), integrator_opts = (dtmax=0.3,), matrix_type = :hessian)\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.InterpolationLineSearch","page":"API","title":"LikelihoodProfiler.InterpolationLineSearch","text":"InterpolationLineSearch\n\nInterpolation-based line search algorithm used in profile stepping.\n\nConstructors\n\nInterpolationLineSearch(; objective_factor=1.25, step_size_factor=2.0, maxiters=10) \n\nKeyword arguments\n\nobjective_factor::Float64 = 1.25: Factor by which the change in the objective function from the last step is increased/decreased to set the target for the next step.\nstep_size_factor::Float64 = 2.0: Multiplicative factor for increasing or decreasing the step size during the search.\nmaxiters::Int = 10: Maximum number of line search iterations allowed.\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.LineSearchStep","page":"API","title":"LikelihoodProfiler.LineSearchStep","text":"LineSearchStep{S, L}\n\nProfiler stepper that uses a line search to adaptively determine the step size in the direction which is chosen by the direction keyword argument.\n\nConstructors\n\nLineSearchStep(;initial_step=DEFAULT_INIT_STEP, direction=:Secant, linesearch=InterpolationLineSearch())\n\nKeyword arguments\n\ninitial_step=DEFAULT_INIT_STEP: Initial guess for the step size. Can be a number (for a constant guess) or a function (pars, idx) -> step for custom logic depending on the current parameters and index. If a number is provided, it is automatically wrapped as a function.\ndirection::Symbol=:Secant: Strategy for choosing the direction of the next step. Options:\n:SingleAxis: Move along the current profiling parameter only.\n:Secant: Use the secant direction, i.e., the line connecting the last two points in parameter space (Default).\n:Gradient: Use the gradient of the objective function as the direction.\nThe choice affects how the next step is proposed in parameter space.\nlinesearch::L=InterpolationLineSearch(): Line search algorithm (e.g., InterpolationLineSearch()).\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.OptimizationProfiler","page":"API","title":"LikelihoodProfiler.OptimizationProfiler","text":"OptimizationProfiler{S, opType, optsType}\n\nA profiler method that uses stepwise re-optimization to profile the likelihood function.\n\nFields\n\nstepper::S: The algorithm used to compute the next profile point. Supported steppers include:\nFixedStep: Proposes a constant step size in the profiling direction (Default). \nLineSearchStep: Uses a line search to adaptively determine the step size in the direction which is chosen by the direction keyword argument.\noptimizer::opType: The optimizer used for the optimization process.\noptimizer_opts::optsType: Options for the optimizer. Defaults to NamedTuple().\n\nStepping Options\n\nThe stepper argument controls how the next profile point is chosen. For example:\n\nstepper = FixedStep(initial_step=0.1): Use a constant step size of 0.1.\nstepper = LineSearchStep(direction=:Secant, linesearch=InterpolationLineSearch()): Use a line search with secant direction.\n\nSee the documentation for each stepper type (e.g., ?FixedStep, ?LineSearchStep) for more details and customization options.\n\nExample\n\nusing OptimizationLBFGSB\nprofiler = OptimizationProfiler(; optimizer = LBFGSB(), optimizer_opts = (reltol=1e-4,))\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.ParameterTarget","page":"API","title":"LikelihoodProfiler.ParameterTarget","text":"ParameterTarget{I,B}\n\nProfile target representing profiling of model parameters.\n\nFields\n\nidxs::AbstractVector{<:Integer}: Indices of the parameters being profiled.\nprofile_lower::AbstractVector{<:Real}: Lower bounds for the profile likelihood. \nprofile_upper::AbstractVector{<:Real}: Upper bounds for the profile likelihood. \n\nProfile bounds profile_lower and profile_upper should be vectors of finite numerical values. \n\nConstructors\n\nCreate a target with explicit lower and upper bounds for each index.\n\nParameterTarget(; idxs::AbstractVector{<:Integer}, profile_lower::AbstractVector{<:Real}, profile_upper::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.ProfileLikelihoodProblem","page":"API","title":"LikelihoodProfiler.ProfileLikelihoodProblem","text":"ProfileLikelihoodProblem{T,probType,P}\n\nDefines a profile likelihood problem.\n\nMathematical Specification of a Profile Likelihood Problem:\n\nA problem is specified by:\n\noptprob::OptimizationProblem — wraps your objective (e.g. negative log-likelihood)\noptpars::AbstractVector{<:Real} — parameter values to start profiling from (typically the optimum)\ntarget::AbstractProfileTarget — what to profile (parameters or functions)\n\nConstructors\n\nExplicit target interface (advanced)\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real}, target::AbstractProfileTarget; \n  conf_level::Float64 = 0.95, df::Int = 1, threshold::Union{Nothing,Real} = nothing)\n\ntarget: ParameterTarget (see ParameterTarget) or FunctionTarget (see FunctionTarget) defining what to profile and the profile bounds.\nconf_level: Confidence level for the profile likelihood. Defaults to 0.95.\ndf: Degrees of freedom for the profile likelihood. Defaults to 1.\nthreshold: Profile likelihood threshold. If not provided, computed from conf_level and df. Can be set to Inf if confidence interval endpoint estimation is not required.\n\nParameter profiling sugar\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real};\n  idxs = nothing, profile_lower = nothing, profile_upper = nothing, kwargs...)\n\nidxs: Indices of parameters to profile; Integer or vector of integers; if nothing, profile all parameters.\nprofile_lower, profile_upper: Bounds for profiling. Accept scalars or vectors of finite numbers; if nothing, taken from optprob. If scalar bounds are provided, they will be expanded to match the number of parameters being profiled.\nkwargs...: passed to the explicit target constructor.\n\nFunction profiling sugar\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real};\n  fs = nothing, profile_lower = nothing, profile_upper = nothing, kwargs...)\n\nfs: OptimizationFunction or vector of OptimizationFunction - functions of parameters to be profiled.\n\nprofile_lower, profile_upper: Bounds for profiling. Accept scalars or vectors of finite numbers. If scalar bounds are provided, they will be expanded to match the number of functions being profiled.\nkwargs...: passed to the explicit target constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.ProfileLikelihoodSolution","page":"API","title":"LikelihoodProfiler.ProfileLikelihoodSolution","text":"ProfileLikelihoodSolution{probType,P}\n\nContains the results of a profile likelihood analysis.\n\nFields\n\nprob::probType: The profile likelihood problem ProfileLikelihoodProblem.\nprofiles::P: The computed profile curves.\nelapsed_time::Float64: The time elapsed during the computation.\n\nSelectors\n\nA number of selectors are available to extract information from the sol::ProfileLikelihoodSolution object. These can be applied to each computed profile sol[i]:\n\nendpoints(sol[i]): Returns the confidence interval (CI) endpoints, marking the intersection of the profile with the threshold.\nretcodes(sol[i]): Returns the retcodes of the CI endpoints estimation.\nstats(sol[i]): Returns the statistics of the profile computation.\n\n\n\n\n\n","category":"type"},{"location":"parallel_modes/#Parallel-execution","page":"Parallel execution","title":"Parallel execution","text":"LikelihoodProfiler.jl supports parallel computation to accelerate profile likelihood calculations. All implemented methods support independent computations across parameters and profile branches (\"left\" and \"right\"). Depending on your system configuration and workload, you can leverage either multithreading or distributed processing (workers) for parallel execution.","category":"section"},{"location":"parallel_modes/#Available-parallel-modes","page":"Parallel execution","title":"Available parallel modes","text":"Parallelization is controlled via the parallel_type keyword argument in the solve function.\n\nsolve(plprob, method; parallel_type = :none)\n\nSupported values:\n\n:none (default): Run all profiling computations sequentially.\n:threads: Use Julia's multithreading (i.e. Base.Threads.@threads) across available CPU threads. To enable multithreading, set the JULIA_NUM_THREADS environment variable.\n:distributed: Use Distributed.jl to run tasks across multiple Julia processes (e.g., started via addprocs() or julia -p N).","category":"section"},{"location":"parallel_modes/#Distributed-workers-example","page":"Parallel execution","title":"Distributed workers example","text":"The following example illustrates how to compute profile likelihoods using distributed parallelism across Julia processes in a multi-core (or multi-node) environment.\n\nusing Distributed\n\naddprocs(2)\n\n@everywhere using LikelihoodProfiler, OptimizationLBFGSB, ForwardDiff\n\n@everywhere rosenbrock(x,p) = (1.0 - x[1])^2 + 100.0*(x[2] - x[1]^2)^2\n\nx0 = [1., 1.]\noptf = OptimizationFunction(rosenbrock, AutoForwardDiff())\noptprob = OptimizationProblem(optf, x0)\n\nplprob = ProfileLikelihoodProblem(optprob, x0; profile_lower=-5.0, profile_upper=5.0, threshold = 1.0)\nmeth = OptimizationProfiler(optimizer = LBFGSB(), stepper = FixedStep(; initial_step=0.1))\n\nsol = solve(plprob, meth; parallel_type=:distributed)","category":"section"},{"location":"solution_interface/#solution_interface","page":"Solution interface","title":"Solution Interface","text":"ProfileLikelihoodSolution type is designed to contain the results of a profile likelihood analysis.","category":"section"},{"location":"solution_interface/#Retcodes","page":"Solution interface","title":"Retcodes","text":"sol::ProfileLikelihoodSolution outputs the following retcodes, which are accessible with retcodes(sol[i]) function:\n\n:Identifiable - the profile has intersection with the predefined threshold.\n:NonIdentifiable - the profile doesn't intersect the predefined threshold.\n:MaxIters - maximum number of iterations reached while computing the profile. See maxiters argument to the solve.\n:Failure - the solver (optimizer or integrator) reported failure status, profiling was interrupted. ","category":"section"},{"location":"solution_interface/#Endpoints-(confidence-interval-estimates)","page":"Solution interface","title":"Endpoints (confidence-interval estimates)","text":"endpoints(sol[i]) returns the estimated crossing points of the profile with the chosen likelihood threshold for the i-th profile. ","category":"section"},{"location":"solution_interface/#Visualization-and-tabular-representation","page":"Solution interface","title":"Visualization and tabular representation","text":"The recipes are defined to visualize profiles saved in sol::ProfileLikelihoodSolution with Plots.jl package: plot(sol), plot(sol[i]).  The following keyword arguments can be used in plot function:\n\nsteps::Bool - whether to scatter steps performed by the profiler. Defaults to true.\nthreshold::Bool - whether to plot threshold defined in ProfileLikelihoodProblem. Defaults to isfinite(threshold)\n\nAlso each profile contained in the sol::ProfileLikelihoodSolution can be represented as a DataFrame with DataFrame(sol[i]).","category":"section"},{"location":"solution_interface/#LikelihoodProfiler.ProfileLikelihoodSolution-solution_interface","page":"Solution interface","title":"LikelihoodProfiler.ProfileLikelihoodSolution","text":"ProfileLikelihoodSolution{probType,P}\n\nContains the results of a profile likelihood analysis.\n\nFields\n\nprob::probType: The profile likelihood problem ProfileLikelihoodProblem.\nprofiles::P: The computed profile curves.\nelapsed_time::Float64: The time elapsed during the computation.\n\nSelectors\n\nA number of selectors are available to extract information from the sol::ProfileLikelihoodSolution object. These can be applied to each computed profile sol[i]:\n\nendpoints(sol[i]): Returns the confidence interval (CI) endpoints, marking the intersection of the profile with the threshold.\nretcodes(sol[i]): Returns the retcodes of the CI endpoints estimation.\nstats(sol[i]): Returns the statistics of the profile computation.\n\n\n\n\n\n","category":"type"},{"location":"case_studies/gaussian/#Mean-of-a-Gaussian-Distribution","page":"Mean of a Gaussian Distribution","title":"Mean of a Gaussian Distribution","text":"This tutorial demonstrates the basic workflow of LikelihoodProfiler.jl using one of the simplest statistical models: estimating the mean of a Gaussian distribution with known variance.","category":"section"},{"location":"case_studies/gaussian/#Model-and-Data","page":"Mean of a Gaussian Distribution","title":"Model and Data","text":"We assume we observe i.i.d. data:\n\nX_1 ldots X_n sim mathcalN(mu 1)\n\nand want to construct a confidence interval for the mean parameter μ. \n\nusing LikelihoodProfiler, OptimizationLBFGSB, Distributions, Random\nusing Plots\n\nRandom.seed!(73612768)\n\nn_obs = 10\ndata = rand(Normal(0, 1), n_obs)","category":"section"},{"location":"case_studies/gaussian/#Objective-Function-(Negative-Log-Likelihood)","page":"Mean of a Gaussian Distribution","title":"Objective Function (Negative Log-Likelihood)","text":"With known variance sigma^2 = 1, the log-likelihood for μ is:\n\nell(mu) = sum_i=1^n log mathcalN(x_i mid mu 1)\n\nWe minimize negative log-likelihood:\n\nobj(x, p) = -sum(logpdf.(Normal(x[1], 1.0), data))","category":"section"},{"location":"case_studies/gaussian/#Maximum-Likelihood-Estimate","page":"Mean of a Gaussian Distribution","title":"Maximum Likelihood Estimate","text":"x0 = [1.0]   # initial guess\n\noptf = OptimizationFunction(obj, AutoForwardDiff())\noptprob = OptimizationProblem(optf, x0)\nsol = solve(optprob, LBFGSB())\n\noptpars = sol.u   # MLE of μ\n\nFor a Gaussian with known variance, this should be very close to the sample mean.","category":"section"},{"location":"case_studies/gaussian/#Profile-Likelihood-for-the-Mean","page":"Mean of a Gaussian Distribution","title":"Profile Likelihood for the Mean","text":"We now build the ProfileLikelihoodProblem, define profiling method and solve the problem. In this model there is one parameter, so the profile is one-dimensional.\n\nplprob = ProfileLikelihoodProblem( optprob, optpars; \n    profile_lower = -3.0, profile_upper = 3.0)\n\nmethod = OptimizationProfiler(optimizer = LBFGSB(),\n    stepper = FixedStep(; initial_step = 0.01))\n\nsol = solve(plprob, method)\nplot(sol, size=(800,300), margins=5Plots.mm)","category":"section"},{"location":"case_studies/gaussian/#Interpreting-the-plot","page":"Mean of a Gaussian Distribution","title":"Interpreting the plot","text":"The curve shows how the negative log-likelihood increases as μ moves away from its MLE.\nThe horizontal line marks the confidence threshold for the chosen level (default 95%).\nThe intersection points give the profile likelihood confidence interval.","category":"section"},{"location":"case_studies/gaussian/#Extracting-Confidence-Interval-Endpoints","page":"Mean of a Gaussian Distribution","title":"Extracting Confidence Interval Endpoints","text":"ProfileLikelihoodSolution stores the computed profile curves together with confidence interval endpoints and identification retcodes, which indicate whether each parameter is practically identifiable. These values can be accessed directly:\n\nretcodes(sol)\nendpoints(sol)","category":"section"},{"location":"case_studies/taxol/#Taxol-model","page":"Taxol model","title":"Taxol model","text":"As an example of practical identifiability analysis, we use the Cancer Taxol Treatment Model. It is an ODE model with 3 state variables and 5 parameters. The identifiability of this model was studied in Marisa C.Eisenberg, Harsh V.Jain. A confidence building exercise in data and identifiability. We have translated author's MATLAB code into Julia. The model is defined by the following system of differential equations:\n\nusing LikelihoodProfiler, OptimizationLBFGSB, OrdinaryDiffEq, Distributions, Plots\n\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_de.m\nfunction ode_func(du, u, p, t, drug)\n  let (a0, ka, r0, d0, kd) = (p[1], p[2], p[3], p[4], p[5])\n\n      K   = 10.515*100\n      V0  = 1.3907*K\n      lam = 9.5722\n\n      theta = 10.\n\n      # Values taken from \n      aRP  = 20.     # per day from Kim_PrlifQuies\n\n      Ncel = u[1] + u[2] + u[3]\n      Lfac = ((K-Ncel)^theta)/((V0^theta) + ((K-Ncel)^theta))\n\n      arstexp = 3.\n      adthexp = 4.\n\n      arst = a0*(drug^arstexp)/(ka^arstexp + (drug^arstexp))\n      adth = d0*(drug^adthexp)/(kd^adthexp + (drug^adthexp))\n      arcv = r0\n\n      # The differntial equations\n      du[1] = -lam*u[1] + aRP*u[2]*Lfac - arst*u[1] + arcv*u[3]\n      du[2] = 2*lam*u[1] - aRP*u[2]*Lfac\n      du[3] = arst*u[1] - adth*u[3] - arcv*u[3]\n  end\nend\n\nExperimental datasets are also provided in the cancer-chemo-identifiability repo for four drug doses (5, 10, 40, 100)\n\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_fit.m\n\n# Data from Terzis et al. Brit J Cancer 1997;75:1744.\n# From Bowman et al. Glia 1999;27:22, glioma cell volume is 0.916\n# picoliters, 1 mm^3 = 1e6 pl or ~1.091 million cells\n\ntimes = [0., 3., 6., 9., 12., 15.]   # days\n\ndose = [5., 10., 40., 100.];    # dose in ng/ml\n\n# Control data\nCell = [0.009, 0.050, 0.120, 0.189, 0.230, 0.260]*1091.0   # thousands of cells\nCerr = [0.006, 0.012, 0.010, 0.011, 0.011, 0.011]*1091.0   # thousands of cells\n\n# 0.005 ug/ml Taxol\nCell005 = [0.009, 0.047, 0.089, 0.149, 0.198, 0.219]*1091.0   # thousands of cells\nCerr005 = [0.006, 0.013, 0.010, 0.011, 0.013, 0.010]*1091.0   # thousands of cells\n\n# 0.010 ug/ml Taxol\nCell010 = [0.009, 0.043, 0.077, 0.093, 0.109, 0.128]*1091.0   # thousands of cells\nCerr010 = [0.006, 0.012, 0.013, 0.012, 0.014, 0.012]*1091.0   # thousands of cells\n\n# 0.040 ug/ml Taxol\nCell040 = [0.009, 0.025, 0.047, 0.054, 0.076, 0.085]*1091.0   # thousands of cells\nCerr040 = [0.005, 0.010, 0.010, 0.011, 0.010, 0.010]*1091.0   # thousands of cells\n\n# 0.100 ug/ml Taxol\nCell100 = [0.009, 0.025, 0.026, 0.028, 0.029, 0.031]*1091.0   # thousands of cells\nCerr100 = [0.006, 0.010, 0.009, 0.008, 0.011, 0.011]*1091.0   # thousands of cells\n\nC005 = mean(Cell005)\nC010 = mean(Cell010)\nC040 = mean(Cell040)\nC100 = mean(Cell100)\n\ndata = [Cell005/C005, Cell010/C010, Cell040/C040, Cell100/C100]\ndatamean = [C005, C010, C040, C100]\n\nNext we define solver options, initial values, optimal parameter values, and tspan\n\n# solver algorithm and tolerances\nsolver_opts = Dict(\n    :alg => AutoTsit5(Rosenbrock23()),\n    :reltol => 1e-6,\n    :abstol => 1e-8\n)\n\n# initial values and parameters\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_soln.m#L3-L6\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_fit.m#L4\n\nu0 = [7.2700, 2.5490, 0.]\np0 = [8.3170, 8.0959, 0.0582, 1.3307, 119.1363] \n\ntspan = (0.,15.)\n\nWe define an objective function (OLS) as in the original publication. The profile likelihood evaluates how this objective changes when one parameter is varied and all other parameters are re-optimized.\n\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_fit.m#L92\n# https://www.mathworks.com/help/optim/ug/lsqcurvefit.html\nfunction taxol_obj(x, _p)\n  loss = 0.\n  for (i,d) in enumerate(dose)\n     prob = ODEProblem((du,u,p,t)->ode_func(du,u,p,t,d), u0, tspan, x)\n     sol = solve(prob, \n                 solver_opts[:alg], \n                 reltol=solver_opts[:reltol],\n                 abstol=solver_opts[:abstol],\n                 saveat=times)\n      \n     sim = (sol[1,:] + sol[2,:] + sol[3,:])/datamean[i]\n     loss += sum((sim-data[i]).^2)\n  end\n  return loss\nend\n\nWe define the threshold as in the original publication. The threshold line represents the value of the objective function (or negative log-likelihood) that corresponds to the chosen confidence level. Where the profile curve intersects this threshold gives the lower and upper CI bounds.\n\n# threshold is chosen according to\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_fit.m#L40-L41\nsigmasq = (mean([(Cerr005/C005); (Cerr010/C010); (Cerr040/C040); (Cerr100/C100)]))^2\nthreshold = sigmasq*chi2_quantile(0.95, 5)\n\nNext, we construct the profile likelihood problem ProfileLikelihoodProblem for the five unknown parameters:\n\nlb = [2.0, 2.0, 0.01, 0.05, 30.]\nub = [30.0, 30.0, 0.6, 5.0, 250.0]\n\noptf = OptimizationFunction(taxol_obj, AutoForwardDiff())\noptprob = OptimizationProblem(optf, p0; lb=lb, ub=ub)\n\nplprob = ProfileLikelihoodProblem(optprob, p0; threshold)\n\nHere we select one of the profiling methods: OptimizationProfiler with the FixedStep stepping algorithm (see Profile Likelihood Methods for details). For each profiled parameter, this algorithm takes fixed-size steps to the left and right of the optimal parameter value and reoptimizes all remaining parameters using the chosen optimizer to obtain the next point on the profile curve.FixedStep uses the same step size (initial_step) for all steps of a given parameter, but allows different parameters to have different step sizes. In this example, we set the initial step to 10% of the parameter’s optimal value, providing a reasonable scale for exploring the likelihood curve.\n\nprofile_step(p0, i) = p0[i] * 0.1\nmethod = OptimizationProfiler(optimizer = LBFGSB(), stepper = FixedStep(; initial_step=profile_step))\nsol = solve(plprob, method)\n\nProfileLikelihoodSolution stores the computed profile curves together with confidence interval endpoints and identification retcodes, which indicate whether each parameter is practically identifiable. These values can be accessed directly:\n\nretcodes(sol)\nendpoints(sol)\n\nFinally, we plot the resulting profiles. Each point on the curve corresponds to a profiler step, i.e., a constrained optimization performed at a fixed value of the profiled parameter. The horizontal line indicates the likelihood threshold for the chosen confidence level; its intersections with the curve define the confidence interval bounds. Steeper profiles indicate better identifiability, whereas flat curves or curves that never intersect the threshold indicate parameters that are not practically identifiable.\n\nplot(sol, size=(800,300), margins=5Plots.mm)","category":"section"},{"location":"#LikelihoodProfiler.jl:-Unified-Interface-to-Profile-Likelihood-Methods","page":"LikelihoodProfiler.jl: Unified Interface to Profile Likelihood Methods","title":"LikelihoodProfiler.jl: Unified Interface to Profile Likelihood Methods","text":"LikelihoodProfiler.jl is a Julia package for practical identifiability analysis and confidence intervals estimation using the profile likelihood approach. The package provides a unified interface for various profile likelihood methods, including optimization-based OptimizationProfiler and integration-based profiles IntegrationProfiler, CI endpoints search CICOProfiler, and more.","category":"section"},{"location":"#Who-is-this-package-for?","page":"LikelihoodProfiler.jl: Unified Interface to Profile Likelihood Methods","title":"Who is this package for?","text":"LikelihoodProfiler.jl is intended for researchers and practitioners working with maximum-likelihood estimation (MLE) problems in any scientific or engineering domain. The package does not assume a specific model type and can be applied to statistical models, mechanistic models, models defined through simulations, optimization problems, or arbitrary likelihood functions. Applicable to a broad class of MLE problems, profile likelihood is especially valuable for complex nonlinear models — such as high-dimensional mechanistic models — where standard asymptotic confidence intervals can be unreliable.\n\nTypical application areas include (but are not limited to):\n\nSystems biology & Quantitative Systems Pharmacology,\nEngineering and control,\nScientific Machine Learning and any field requiring identifiability and uncertainty analysis of MLE parameters.","category":"section"},{"location":"#What-problems-does-this-package-solve?","page":"LikelihoodProfiler.jl: Unified Interface to Profile Likelihood Methods","title":"What problems does this package solve?","text":"Profile likelihood methods provide insight into practical identifiability - how precisely model parameters (or predictions derived from them) are determined by the available data. LikelihoodProfiler.jl offers a unified interface for:\n\nParameter profile likelihoods. Profile the likelihood function to explore how well parameters are constrained by the data.\nConfidence intervals for parameters. Estimate confidence intervals for parameter values based on likelihood threshold to quantify the level of certainty in the parameter estimates.\nFunctional profile likelihoods.  Profile arbitrary functions of the parameters (e.g., predictions, reparameterizations, etc).\n\nThese capabilities apply to any setting where an MLE objective (e.g., negative log-likelihood) can be evaluated.","category":"section"},{"location":"#Installation","page":"LikelihoodProfiler.jl: Unified Interface to Profile Likelihood Methods","title":"Installation","text":"In Julia terminal run the following command:\n\nimport Pkg; Pkg.add(\"LikelihoodProfiler\")","category":"section"},{"location":"#Related-packages","page":"LikelihoodProfiler.jl: Unified Interface to Profile Likelihood Methods","title":"Related packages","text":"Other implementations of the profile likelihood approach in Julia include:\n\nProfileLikelihood.jl implements fixed-step optimization-based profiles and supports bivariate profile likelihoods.\nInformationalGeometry.jl implements various methods to study likelihood functions (including profile likelihood) using the tools of differential geometry.\n\nThere are also well-known profile likelihood implementations in other languages, namely: Data2Dynamics, dMod, pyPESTO, sbioparametersci","category":"section"},{"location":"#Citation","page":"LikelihoodProfiler.jl: Unified Interface to Profile Likelihood Methods","title":"Citation","text":"Borisov I., Metelkin E. An Algorithm for Practical Identifiability Analysis and Confidence Intervals Evaluation Based on Constrained Optimization. 2018. October. ICSB2018. https://doi.org/10.13140/RG.2.2.18935.06563","category":"section"},{"location":"problem_interface/#Defining-a-ProfileLikelihoodProblem","page":"Problem interface","title":"Defining a ProfileLikelihoodProblem","text":"ProfileLikelihoodProblem type is designed to contain the necessary information to define a profile likelihood problem.","category":"section"},{"location":"problem_interface/#Targets-(what-you-profile)","page":"Problem interface","title":"Targets (what you profile)","text":"A profile target specifies the quantity whose profile you want: either one or more parameters by index, or one or more functions of the parameters. Targets carry their own profile bounds (profile_lower, profile_upper) which delimit where each profile is traced.","category":"section"},{"location":"problem_interface/#ParameterTarget","page":"Problem interface","title":"ParameterTarget","text":"ParameterTarget profiles model parameters by index.  While you can build ParameterTarget directly, most users prefer the convenience constructor on ProfileLikelihoodProblem, which accepts idxs and bounds and constructs the target for you. See ProfileLikelihoodProblem interface.","category":"section"},{"location":"problem_interface/#Explicit-construction-example","page":"Problem interface","title":"Explicit construction example","text":"using LikelihoodProfiler\n\nf = OptimizationFunction((θ,p)->sum(abs2, θ))\noptprob = OptimizationProblem(f, [1.0, 2.0, 3.0])\n\npt = ParameterTarget(; idxs=[1,3],\n                     profile_lower=[-5.0, -1.0],\n                     profile_upper=[ 2.0,  4.0])\n\nplprob = ProfileLikelihoodProblem(optprob, [0.0, 0.0, 0.0], pt;\n                                  conf_level=0.95)  # threshold derived from χ²","category":"section"},{"location":"problem_interface/#FunctionTarget","page":"Problem interface","title":"FunctionTarget","text":"FunctionTarget profiles functions of the parameters. While you can build FunctionTarget directly, most users prefer the convenience constructor on ProfileLikelihoodProblem, which accepts functions and bounds and constructs the target for you. See ProfileLikelihoodProblem interface.","category":"section"},{"location":"problem_interface/#Explicit-construction-example-2","page":"Problem interface","title":"Explicit construction example","text":"using LikelihoodProfiler\n\nf = OptimizationFunction((θ,p)->sum(abs2, θ))\noptprob = OptimizationProblem(f, [1.0, 2.0, 3.0])\n\ng1 = OptimizationFunction((θ,p)->θ[1] + θ[2])\ng2 = OptimizationFunction((θ,p)->θ[2] - θ[3])\n\nft = FunctionTarget(; fs=[g1,g2],\n                    profile_lower=[-2.0, -1.0],\n                    profile_upper=[ 2.0,  1.0])\n\nplprob = ProfileLikelihoodProblem(optprob, [0.0, 0.0, 0.0], ft)","category":"section"},{"location":"problem_interface/#Problem-“sugar”-constructors","page":"Problem interface","title":"Problem “sugar” constructors","text":"For ergonomics, ProfileLikelihoodProblem provides keyword constructors that build the target for you.\n\nProfileLikelihoodProblem(::OptimizationProblem, ::AbstractVector{<:Real}; idxs, profile_lower, profile_upper)\nProfileLikelihoodProblem(::OptimizationProblem, ::AbstractVector{<:Real}, ::Union{OptimizationFunction,AbstractVector{<:OptimizationFunction}}; profile_lower, profile_upper)","category":"section"},{"location":"problem_interface/#LikelihoodProfiler.ProfileLikelihoodProblem-problem_interface","page":"Problem interface","title":"LikelihoodProfiler.ProfileLikelihoodProblem","text":"ProfileLikelihoodProblem{T,probType,P}\n\nDefines a profile likelihood problem.\n\nMathematical Specification of a Profile Likelihood Problem:\n\nA problem is specified by:\n\noptprob::OptimizationProblem — wraps your objective (e.g. negative log-likelihood)\noptpars::AbstractVector{<:Real} — parameter values to start profiling from (typically the optimum)\ntarget::AbstractProfileTarget — what to profile (parameters or functions)\n\nConstructors\n\nExplicit target interface (advanced)\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real}, target::AbstractProfileTarget; \n  conf_level::Float64 = 0.95, df::Int = 1, threshold::Union{Nothing,Real} = nothing)\n\ntarget: ParameterTarget (see ParameterTarget) or FunctionTarget (see FunctionTarget) defining what to profile and the profile bounds.\nconf_level: Confidence level for the profile likelihood. Defaults to 0.95.\ndf: Degrees of freedom for the profile likelihood. Defaults to 1.\nthreshold: Profile likelihood threshold. If not provided, computed from conf_level and df. Can be set to Inf if confidence interval endpoint estimation is not required.\n\nParameter profiling sugar\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real};\n  idxs = nothing, profile_lower = nothing, profile_upper = nothing, kwargs...)\n\nidxs: Indices of parameters to profile; Integer or vector of integers; if nothing, profile all parameters.\nprofile_lower, profile_upper: Bounds for profiling. Accept scalars or vectors of finite numbers; if nothing, taken from optprob. If scalar bounds are provided, they will be expanded to match the number of parameters being profiled.\nkwargs...: passed to the explicit target constructor.\n\nFunction profiling sugar\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real};\n  fs = nothing, profile_lower = nothing, profile_upper = nothing, kwargs...)\n\nfs: OptimizationFunction or vector of OptimizationFunction - functions of parameters to be profiled.\n\nprofile_lower, profile_upper: Bounds for profiling. Accept scalars or vectors of finite numbers. If scalar bounds are provided, they will be expanded to match the number of functions being profiled.\nkwargs...: passed to the explicit target constructor.\n\n\n\n\n\n","category":"type"},{"location":"problem_interface/#LikelihoodProfiler.ParameterTarget-problem_interface","page":"Problem interface","title":"LikelihoodProfiler.ParameterTarget","text":"ParameterTarget{I,B}\n\nProfile target representing profiling of model parameters.\n\nFields\n\nidxs::AbstractVector{<:Integer}: Indices of the parameters being profiled.\nprofile_lower::AbstractVector{<:Real}: Lower bounds for the profile likelihood. \nprofile_upper::AbstractVector{<:Real}: Upper bounds for the profile likelihood. \n\nProfile bounds profile_lower and profile_upper should be vectors of finite numerical values. \n\nConstructors\n\nCreate a target with explicit lower and upper bounds for each index.\n\nParameterTarget(; idxs::AbstractVector{<:Integer}, profile_lower::AbstractVector{<:Real}, profile_upper::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"problem_interface/#LikelihoodProfiler.FunctionTarget-problem_interface","page":"Problem interface","title":"LikelihoodProfiler.FunctionTarget","text":"FunctionTarget{F,B}\n\nProfile target representing profiling of functions of model parameters.\n\nFields\n\nfs::AbstractVector{<:OptimizationFunction}: Functions of the parameters being profiled.\nprofile_lower::AbstractVector{<:Real}: Lower bounds for the profile likelihood. \nprofile_upper::AbstractVector{<:Real}: Upper bounds for the profile likelihood. \n\nProfile bounds profile_lower and profile_upper should be vectors of finite numerical values. \n\nConstructors\n\nCreate a target with explicit lower and upper bounds for each function of parameters.\n\nFunctionTarget(; fs::AbstractVector{<:OptimizationFunction}, profile_lower::AbstractVector{<:Real}, profile_upper::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"rosenbrock/#Getting-Started-with-LikelihoodProfiler","page":"Getting Started","title":"Getting Started with LikelihoodProfiler","text":"LikelihoodProfiler.jl provides tools for computing profile likelihoods, confidence intervals, and prediction profiles for maximum-likelihood estimation (MLE) problems.   To define a ProfileLikelihoodProblem, you need two ingredients:\n\nan objective function (typically a negative log-likelihood or a least-squares loss), and  \nthe optimal parameter values, i.e., the parameter vector that minimizes the objective.\n\nProfile likelihood analysis requires evaluating the objective function under parameter perturbations. To define the objective function and its associated optimization problem LikelihoodProfiler.jl builds directly on the Optimization.jl interface. Internally, every ProfileLikelihoodProblem wraps an OptimizationProblem, so anything you can optimize with Optimization.jl can be profiled here.\n\nBelow we illustrate the basic workflow using a simple artificial objective function: the Rosenbrock function.   More realistic applications (ODE models, statistical models) are shown in the Tutorials section.\n\nFirst we define the OptimizationProblem and solve it with the preferred optimizer to obtain the optimal values of the parameters. ","category":"section"},{"location":"rosenbrock/#Define-and-solve-the-optimization-problem","page":"Getting Started","title":"Define and solve the optimization problem","text":"We begin by defining the objective function and solving the optimization problem to obtain the optimal values of the parameters:\n\nusing LikelihoodProfiler, OptimizationLBFGSB, OrdinaryDiffEq, CICOBase\nusing Plots\n\n# objective function\nrosenbrock(x,p) = (1.0 - x[1])^2 + 100.0*(x[2] - x[1]^2)^2\n\n# initial values\nx0 = zeros(2)\n\n# solving optimization problem\noptf = OptimizationFunction(rosenbrock, AutoForwardDiff())\noptprob = OptimizationProblem(optf, x0)\nsol = solve(optprob, LBFGSB())","category":"section"},{"location":"rosenbrock/#Profile-Likelihood-Problem-Interface","page":"Getting Started","title":"Profile Likelihood Problem Interface","text":"To construct a ProfileLikelihoodProblem, we provide the OptimizationProblem together with the optimal parameter values obtained from solving it. We can also set the profiling domain with the profile_lower, profile_upper arguments, indicies of parameters to profile with idxs and the threshold, which is the confidence level required to estimate confidence intervals. Please consult ?ProfileLikelihoodProblem on the details of the interface.\n\n# optimal values of the parameters\noptpars = sol.u\n\n# profile likelihood problem\nplprob = ProfileLikelihoodProblem(optprob, optpars; profile_lower = -10., profile_upper=10., threshold = 4.0)","category":"section"},{"location":"rosenbrock/#Profile-Likelihood-Methods","page":"Getting Started","title":"Profile Likelihood Methods","text":"LikelihoodProfiler provides a range of methods to profile likelihood functions and explore practical identifiability. All methods use the same solve interface but differ in how the profiles and the associated confidence intervals are computed. The solve interface exposes a set of common options shared across all profiling methods—such as parallel_type for parallel execution, verbose for controlling output, and reoptimize_init to trigger re-optimization of the initial parameter values before profiling begins.\n\nFor a more detailed description of each method, see the Profile Likelihood Methods section.","category":"section"},{"location":"rosenbrock/#OptimizationProfiler","page":"Getting Started","title":"OptimizationProfiler","text":"The most direct profiling method is OptimizationProfiler. It computes the profile by taking a sequence of fixed steps in the profiled parameter and performing a re-optimization of all remaining parameters at each step. This produces a discrete set of points that approximate the profile curve.\n\nmeth_opt = OptimizationProfiler(optimizer = LBFGSB(), stepper = FixedStep(; initial_step=0.15))\nsol1 = solve(plprob, meth_opt)\nplot(sol1, size=(800,300), margins=5Plots.mm)","category":"section"},{"location":"rosenbrock/#IntegrationProfiler","page":"Getting Started","title":"IntegrationProfiler","text":"A more advanced technique is implemented in IntegrationProfiler. Instead of repeatedly re-optimizing parameters, this method internally formulates a differential equation system whose solution traces the profile likelihood trajectory. To integrate this system, the user must provide a differential equation solver (integrator).\n\nmeth_integ = IntegrationProfiler(integrator = Tsit5(), integrator_opts = (dtmax=0.3,), matrix_type = :hessian)\nsol2 = solve(plprob, meth_integ)\nplot(sol2, size=(800,300), margins=5Plots.mm)","category":"section"},{"location":"rosenbrock/#CICOProfiler","page":"Getting Started","title":"CICOProfiler","text":"Often, the primary goal of likelihood profiling is to determine whether the profile intersects the confidence threshold—i.e., whether the parameter has a finite confidence interval. CICOProfiler focuses on this directly: it estimates the confidence interval endpoints without reconstructing the full profile curve.\n\nmeth_cico = CICOProfiler(optimizer = :LN_NELDERMEAD, scan_tol = 1e-4)\nsol3 = solve(plprob, meth_cico)\nplot(sol3, size=(800,300), margins=5Plots.mm)","category":"section"},{"location":"rosenbrock/#Profile-Likelihood-Solution","page":"Getting Started","title":"Profile Likelihood Solution","text":"A ProfileLikelihoodSolution stores more than just the profile curves (see Solution Interface). It also contains the estimated confidence-interval endpoints and identification retcodes, which indicate whether each parameter (or function of parameters) is practically identifiable. These values can be accessed directly:\n\nretcodes(sol3)\n\nendpoints(sol3)","category":"section"}]
}
