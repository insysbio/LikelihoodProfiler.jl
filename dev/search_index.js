var documenterSearchIndex = {"docs":
[{"location":"profile_methods/#Profile-likelihood-methods","page":"Profile likelihood methods","title":"Profile likelihood methods","text":"","category":"section"},{"location":"profile_methods/","page":"Profile likelihood methods","title":"Profile likelihood methods","text":"LikelihoodProfiler provides a range of methods to profile likelihood functions and explore practical identifiability. The method should be provided as the second argument to the solve function.","category":"page"},{"location":"profile_methods/#Optimization-based-profiles","page":"Profile likelihood methods","title":"Optimization-based profiles","text":"","category":"section"},{"location":"profile_methods/","page":"Profile likelihood methods","title":"Profile likelihood methods","text":"The method computes profiles for each parameter by iteratively changing the value of the parameter and re-optimizing the likelihood function with respect to all other parameters. ","category":"page"},{"location":"profile_methods/#LikelihoodProfiler.OptimizationProfiler-profile_methods","page":"Profile likelihood methods","title":"LikelihoodProfiler.OptimizationProfiler","text":"OptimizationProfiler{S, opType, optsType}\n\nA profiler method that uses stepwise re-optimization to profile the likelihood function.\n\nFields\n\nstepper::S: The algorithm used to compute the next profile point. Supported steppers include:\nFixedStep: Proposes a constant step size in the profiling direction (Default). \nLineSearchStep: Uses a line search to adaptively determine the step size in the direction which is chosen by the direction keyword argument.\noptimizer::opType: The optimizer used for the optimization process.\noptimizer_opts::optsType: Options for the optimizer. Defaults to NamedTuple().\n\nStepping Options\n\nThe stepper argument controls how the next profile point is chosen. For example:\n\nstepper = FixedStep(initial_step=0.1): Use a constant step size of 0.1.\nstepper = LineSearchStep(direction=:Secant, linesearch=InterpolationLineSearch()): Use a line search with secant direction.\n\nSee the documentation for each stepper type (e.g., ?FixedStep, ?LineSearchStep) for more details and customization options.\n\nExample\n\nusing Optimization\nprofiler = OptimizationProfiler(; optimizer = Optimization.LBFGS(), optimizer_opts = (reltol=1e-4,))\n\n\n\n\n\n","category":"type"},{"location":"profile_methods/#Integration-based-profiles","page":"Profile likelihood methods","title":"Integration-based profiles","text":"","category":"section"},{"location":"profile_methods/","page":"Profile likelihood methods","title":"Profile likelihood methods","text":"The method computes profiles for each parameter (or function of parameters) by integrating the differential equations system. ","category":"page"},{"location":"profile_methods/#LikelihoodProfiler.IntegrationProfiler-profile_methods","page":"Profile likelihood methods","title":"LikelihoodProfiler.IntegrationProfiler","text":"IntegrationProfiler{opType, optsType, DEAlg, DEOpts}\n\nA profiler method that uses integration of differential equations system to profile the likelihood function.\n\nFields\n\nreoptimize::Bool: Indicates whether to re-optimization after each step of the integrator. Defaults to false.\noptimizer::opType: The optimizer used for the optimization process. Defaults to nothing.\noptimizer_opts::optsType: Options for the optimizer. Defaults to NamedTuple().\nintegrator::DEAlg: The differential equation algorithm used for integration.\nintegrator_opts::DEOpts: Options for the differential equation solver. Defaults to NamedTuple().\nmatrix_type::Symbol: The type of matrix to be used for the Hessian approximation. Possible options are: :hessian, :identity. Defaults to :hessian.\ngamma::Float64: Correction factor used in integration if full hessian is not computed (e.g. matrix_type = :identity). Defaults to 1.0.\n\nExample\n\nusing OrdinaryDiffEq\nprofiler = IntegrationProfiler(integrator = Tsit5(), integrator_opts = (dtmax=0.3,), matrix_type = :hessian)\n\n\n\n\n\n","category":"type"},{"location":"profile_methods/","page":"Profile likelihood methods","title":"Profile likelihood methods","text":"References:","category":"page"},{"location":"profile_methods/","page":"Profile likelihood methods","title":"Profile likelihood methods","text":"Chen, J.-S. & Jennrich, R. I. Simple Accurate Approximation of Likelihood Profiles. Journal of Computational and Graphical Statistics 11, 714–732 (2002).\nChen, J.-S. & Jennrich, R. I. The Signed Root Deviance Profile and Confidence Intervals in Maximum Likelihood Analysis. Journal of the American Statistical Association 91, 993–998 (1996).","category":"page"},{"location":"profile_methods/#Confidence-Intervals-by-Constrained-Optimization-(CICO)","page":"Profile likelihood methods","title":"Confidence Intervals by Constrained Optimization (CICO)","text":"","category":"section"},{"location":"profile_methods/","page":"Profile likelihood methods","title":"Profile likelihood methods","text":"The method computes intersections (endpoints of the confidence interval (CI)) of the profile with the predefined confidence level (threshold) without restoring the exact trajectory of the profile. Requires using CICOBase package.","category":"page"},{"location":"profile_methods/#LikelihoodProfiler.CICOProfiler-profile_methods","page":"Profile likelihood methods","title":"LikelihoodProfiler.CICOProfiler","text":"CICOProfiler\n\nConfidence Intervals by Constrained Optimization (CICO) method to find the intersections of the likelihood function with the threshold. See CICOBase docs for more details. Requires using CICOBase.\n\nFields\n\noptimizer::Symbol: The optimizer used for the optimization process. Defaults to NLopt :LN_NELDERMEAD.\nscan_tol::Float64: The tolerance for the endpoints scan. Defaults to 1e-3.\n\nExample\n\nprofiler = CICOProfiler(optimizer = :LN_NELDERMEAD, scan_tol = 1e-3)\n\n\n\n\n\n","category":"type"},{"location":"profile_methods/","page":"Profile likelihood methods","title":"Profile likelihood methods","text":"References:","category":"page"},{"location":"profile_methods/","page":"Profile likelihood methods","title":"Profile likelihood methods","text":"Borisov, I. & Metelkin, E. Confidence intervals by constrained optimization—An algorithm and software package for practical identifiability analysis in systems biology. PLoS Comput Biol 16, e1008495 (2020).\nVenzon, D. J. & Moolgavkar, S. H. A Method for Computing Profile-Likelihood-Based Confidence Intervals. Applied Statistics 37, 87 (1988).","category":"page"},{"location":"api/#API-references","page":"API","title":"API references","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The package exports the following functions for parameters and functions identifiability analysis, confidence intervals evaluation and results visualization.","category":"page"},{"location":"api/#CommonSolve.solve-Tuple{ProfileLikelihoodProblem, LikelihoodProfiler.AbstractProfilerMethod}","page":"API","title":"CommonSolve.solve","text":"solve(plprob::ProfileLikelihoodProblem, method::AbstractProfilerMethod; \n        parallel_type::Symbol=:none, maxiters::Int=1e4, verbose::Bool=false)\n\nProfiles the likelihood function for the given problem plprob using the specified profiling method.\n\nArguments\n\nplprob::ProfileLikelihoodProblem: The profiling problem instance containing the parameters and likelihood function to be profiled.\nmethod::AbstractProfilerMethod: The method to be used for profiling.\nreoptimize_init::Bool=false: If true, re-optimizes the model at the provided initial parameter values optpars before profiling. Defaults to false.\nparallel_type::Symbol: Specifies the type of parallelism to be used. Supported values: :none, :threads, :distributed. Defaults to :none.\nmaxiters::Int: Maximum number of iterations for one branch (left and right) of the profiling process. Defaults to 1e4.\nverbose::Bool: Indicates whether to display the progress of the profiling process. Defaults to false.\n\nReturns\n\nReturns the profiling results ProfileLikelihoodSolution.\n\nExample\n\nplprob = ProfileLikelihoodProblem(optprob, optpars; idxs=1, profile_lower=-10., profile_upper=10.)\nmethod = OptimizationProfiler(optimizer = Optimization.LBFGS(), stepper = FixedStep())\nsol = solve(plprob, method)\n\n\n\n\n\n","category":"method"},{"location":"api/#LikelihoodProfiler.chi2_quantile","page":"API","title":"LikelihoodProfiler.chi2_quantile","text":"chi2_quantile(α, df=1)\n\nComputes α quantile for Chi2 distribution with df degrees of freedom\n\n\n\n\n\n","category":"function"},{"location":"api/#LikelihoodProfiler.CICOProfiler","page":"API","title":"LikelihoodProfiler.CICOProfiler","text":"CICOProfiler\n\nConfidence Intervals by Constrained Optimization (CICO) method to find the intersections of the likelihood function with the threshold. See CICOBase docs for more details. Requires using CICOBase.\n\nFields\n\noptimizer::Symbol: The optimizer used for the optimization process. Defaults to NLopt :LN_NELDERMEAD.\nscan_tol::Float64: The tolerance for the endpoints scan. Defaults to 1e-3.\n\nExample\n\nprofiler = CICOProfiler(optimizer = :LN_NELDERMEAD, scan_tol = 1e-3)\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.FixedStep","page":"API","title":"LikelihoodProfiler.FixedStep","text":"FixedStep{S}\n\nProfiler stepper that always proposes a fixed step size in the profiling direction.\n\nConstructors\n\nFixedStep(;initial_step=DEFAULT_INIT_STEP)\n\nKeyword arguments\n\ninitial_step=DEFAULT_INIT_STEP: The initial (and constant) step size to use for each profile step. This can be a number (for a constant step size) or a function (pars, idx) -> step for custom logic depending on the current parameters and index. If a number is provided, it is automatically wrapped as a function.\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.FunctionTarget","page":"API","title":"LikelihoodProfiler.FunctionTarget","text":"FunctionTarget{F,B}\n\nProfile target representing profiling of functions of model parameters.\n\nFields\n\nfs::AbstractVector{<:OptimizationFunction}: Functions of the parameters being profiled.\nprofile_lower::AbstractVector{<:Real}: Lower bounds for the profile likelihood. \nprofile_upper::AbstractVector{<:Real}: Upper bounds for the profile likelihood. \n\nProfile bounds profile_lower and profile_upper should be vectors of finite numerical values. \n\nConstructors\n\nCreate a target with explicit lower and upper bounds for each function of parameters.\n\nFunctionTarget(; fs::AbstractVector{<:OptimizationFunction}, profile_lower::AbstractVector{<:Real}, profile_upper::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.IntegrationProfiler","page":"API","title":"LikelihoodProfiler.IntegrationProfiler","text":"IntegrationProfiler{opType, optsType, DEAlg, DEOpts}\n\nA profiler method that uses integration of differential equations system to profile the likelihood function.\n\nFields\n\nreoptimize::Bool: Indicates whether to re-optimization after each step of the integrator. Defaults to false.\noptimizer::opType: The optimizer used for the optimization process. Defaults to nothing.\noptimizer_opts::optsType: Options for the optimizer. Defaults to NamedTuple().\nintegrator::DEAlg: The differential equation algorithm used for integration.\nintegrator_opts::DEOpts: Options for the differential equation solver. Defaults to NamedTuple().\nmatrix_type::Symbol: The type of matrix to be used for the Hessian approximation. Possible options are: :hessian, :identity. Defaults to :hessian.\ngamma::Float64: Correction factor used in integration if full hessian is not computed (e.g. matrix_type = :identity). Defaults to 1.0.\n\nExample\n\nusing OrdinaryDiffEq\nprofiler = IntegrationProfiler(integrator = Tsit5(), integrator_opts = (dtmax=0.3,), matrix_type = :hessian)\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.InterpolationLineSearch","page":"API","title":"LikelihoodProfiler.InterpolationLineSearch","text":"InterpolationLineSearch\n\nInterpolation-based line search algorithm used in profile stepping.\n\nConstructors\n\nInterpolationLineSearch(; objective_factor=1.25, step_size_factor=2.0, maxiters=10) \n\nKeyword arguments\n\nobjective_factor::Float64 = 1.25: Factor by which the change in the objective function from the last step is increased/decreased to set the target for the next step.\nstep_size_factor::Float64 = 2.0: Multiplicative factor for increasing or decreasing the step size during the search.\nmaxiters::Int = 10: Maximum number of line search iterations allowed.\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.LineSearchStep","page":"API","title":"LikelihoodProfiler.LineSearchStep","text":"LineSearchStep{S, L}\n\nProfiler stepper that uses a line search to adaptively determine the step size in the direction which is chosen by the direction keyword argument.\n\nConstructors\n\nLineSearchStep(;initial_step=DEFAULT_INIT_STEP, direction=:Secant, linesearch=InterpolationLineSearch())\n\nKeyword arguments\n\ninitial_step=DEFAULT_INIT_STEP: Initial guess for the step size. Can be a number (for a constant guess) or a function (pars, idx) -> step for custom logic depending on the current parameters and index. If a number is provided, it is automatically wrapped as a function.\ndirection::Symbol=:Secant: Strategy for choosing the direction of the next step. Options:\n:SingleAxis: Move along the current profiling parameter only.\n:Secant: Use the secant direction, i.e., the line connecting the last two points in parameter space (Default).\n:Gradient: Use the gradient of the objective function as the direction.\nThe choice affects how the next step is proposed in parameter space.\nlinesearch::L=InterpolationLineSearch(): Line search algorithm (e.g., InterpolationLineSearch()).\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.OptimizationProfiler","page":"API","title":"LikelihoodProfiler.OptimizationProfiler","text":"OptimizationProfiler{S, opType, optsType}\n\nA profiler method that uses stepwise re-optimization to profile the likelihood function.\n\nFields\n\nstepper::S: The algorithm used to compute the next profile point. Supported steppers include:\nFixedStep: Proposes a constant step size in the profiling direction (Default). \nLineSearchStep: Uses a line search to adaptively determine the step size in the direction which is chosen by the direction keyword argument.\noptimizer::opType: The optimizer used for the optimization process.\noptimizer_opts::optsType: Options for the optimizer. Defaults to NamedTuple().\n\nStepping Options\n\nThe stepper argument controls how the next profile point is chosen. For example:\n\nstepper = FixedStep(initial_step=0.1): Use a constant step size of 0.1.\nstepper = LineSearchStep(direction=:Secant, linesearch=InterpolationLineSearch()): Use a line search with secant direction.\n\nSee the documentation for each stepper type (e.g., ?FixedStep, ?LineSearchStep) for more details and customization options.\n\nExample\n\nusing Optimization\nprofiler = OptimizationProfiler(; optimizer = Optimization.LBFGS(), optimizer_opts = (reltol=1e-4,))\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.ParameterTarget","page":"API","title":"LikelihoodProfiler.ParameterTarget","text":"ParameterTarget{I,B}\n\nProfile target representing profiling of model parameters.\n\nFields\n\nidxs::AbstractVector{<:Integer}: Indices of the parameters being profiled.\nprofile_lower::AbstractVector{<:Real}: Lower bounds for the profile likelihood. \nprofile_upper::AbstractVector{<:Real}: Upper bounds for the profile likelihood. \n\nProfile bounds profile_lower and profile_upper should be vectors of finite numerical values. \n\nConstructors\n\nCreate a target with explicit lower and upper bounds for each index.\n\nParameterTarget(; idxs::AbstractVector{<:Integer}, profile_lower::AbstractVector{<:Real}, profile_upper::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.ProfileLikelihoodProblem","page":"API","title":"LikelihoodProfiler.ProfileLikelihoodProblem","text":"ProfileLikelihoodProblem{T,probType,P}\n\nDefines a profile likelihood problem.\n\nMathematical Specification of a Profile Likelihood Problem:\n\nA problem is specified by:\n\noptprob::OptimizationProblem — wraps your objective (e.g. negative log-likelihood)\noptpars::AbstractVector{<:Real} — parameter values to start profiling from (typically the optimum)\ntarget::AbstractProfileTarget — what to profile (parameters or functions)\n\nConstructors\n\nExplicit target interface (advanced)\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real}, target::AbstractProfileTarget; \n  conf_level::Float64 = 0.95, df::Int = 1, threshold::Union{Nothing,Real} = nothing)\n\ntarget: ParameterTarget (see ParameterTarget) or FunctionTarget (see FunctionTarget) defining what to profile and the profile bounds.\nconf_level: Confidence level for the profile likelihood. Defaults to 0.95.\ndf: Degrees of freedom for the profile likelihood. Defaults to 1.\nthreshold: Profile likelihood threshold. If not provided, computed from conf_level and df. Can be set to Inf if confidence interval endpoint estimation is not required.\n\nParameter profiling sugar\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real};\n  idxs = nothing, profile_lower = nothing, profile_upper = nothing, kwargs...)\n\nidxs: Indices of parameters to profile; Integer or vector of integers; if nothing, profile all parameters.\nprofile_lower, profile_upper: Bounds for profiling. Accept scalars or vectors of finite numbers; if nothing, taken from optprob. If scalar bounds are provided, they will be expanded to match the number of parameters being profiled.\nkwargs...: passed to the explicit target constructor.\n\nFunction profiling sugar\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real};\n  fs = nothing, profile_lower = nothing, profile_upper = nothing, kwargs...)\n\nfs: OptimizationFunction or vector of OptimizationFunction - functions of parameters to be profiled.\n\nprofile_lower, profile_upper: Bounds for profiling. Accept scalars or vectors of finite numbers. If scalar bounds are provided, they will be expanded to match the number of functions being profiled.\nkwargs...: passed to the explicit target constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/#LikelihoodProfiler.ProfileLikelihoodSolution","page":"API","title":"LikelihoodProfiler.ProfileLikelihoodSolution","text":"ProfileLikelihoodSolution{probType,P}\n\nContains the results of a profile likelihood analysis.\n\nFields\n\nprob::probType: The profile likelihood problem ProfileLikelihoodProblem.\nprofiles::P: The computed profile curves.\nelapsed_time::Float64: The time elapsed during the computation.\n\nSelectors\n\nA number of selectors are available to extract information from the sol::ProfileLikelihoodSolution object. These can be applied to each computed profile sol[i]:\n\nendpoints(sol[i]): Returns the confidence interval (CI) endpoints, marking the intersection of the profile with the threshold.\nretcodes(sol[i]): Returns the retcodes of the CI endpoints estimation.\nstats(sol[i]): Returns the statistics of the profile computation.\n\n\n\n\n\n","category":"type"},{"location":"parallel_modes/#Parallel-execution","page":"Parallel execution","title":"Parallel execution","text":"","category":"section"},{"location":"parallel_modes/","page":"Parallel execution","title":"Parallel execution","text":"LikelihoodProfiler.jl supports parallel computation to accelerate profile likelihood calculations. All implemented methods support independent computations across parameters and profile branches (\"left\" and \"right\"). Depending on your system configuration and workload, you can leverage either multithreading or distributed processing (workers) for parallel execution.","category":"page"},{"location":"parallel_modes/#Available-parallel-modes","page":"Parallel execution","title":"Available parallel modes","text":"","category":"section"},{"location":"parallel_modes/","page":"Parallel execution","title":"Parallel execution","text":"Parallelization is controlled via the parallel_type keyword argument in the solve function.","category":"page"},{"location":"parallel_modes/","page":"Parallel execution","title":"Parallel execution","text":"solve(plprob, method; parallel_type = :none)","category":"page"},{"location":"parallel_modes/","page":"Parallel execution","title":"Parallel execution","text":"Supported values:","category":"page"},{"location":"parallel_modes/","page":"Parallel execution","title":"Parallel execution","text":":none (default): Run all profiling computations sequentially.\n:threads: Use Julia's multithreading (i.e. Base.Threads.@threads) across available CPU threads. To enable multithreading, set the JULIA_NUM_THREADS environment variable.\n:distributed: Use Distributed.jl to run tasks across multiple Julia processes (e.g., started via addprocs() or julia -p N).","category":"page"},{"location":"parallel_modes/#Distributed-workers-example","page":"Parallel execution","title":"Distributed workers example","text":"","category":"section"},{"location":"parallel_modes/","page":"Parallel execution","title":"Parallel execution","text":"The following example illustrates how to compute profile likelihoods using distributed parallelism across Julia processes in a multi-core (or multi-node) environment.","category":"page"},{"location":"parallel_modes/","page":"Parallel execution","title":"Parallel execution","text":"using Distributed\n\naddprocs(2)\n\n@everywhere using LikelihoodProfiler, Optimization, ForwardDiff\n\n@everywhere rosenbrock(x,p) = (1.0 - x[1])^2 + 100.0*(x[2] - x[1]^2)^2\n\nx0 = [1., 1.]\noptf = OptimizationFunction(rosenbrock, AutoForwardDiff())\noptprob = OptimizationProblem(optf, x0)\n\nplprob = ProfileLikelihoodProblem(optprob, x0; profile_lower=-5.0, profile_upper=5.0, threshold = 1.0)\nmeth = OptimizationProfiler(optimizer = Optimization.LBFGS(), stepper = FixedStep(; initial_step=0.1))\n\nsol = solve(plprob, meth; parallel_type=:distributed)","category":"page"},{"location":"solution_interface/#Solution-interface","page":"Solution interface","title":"Solution interface","text":"","category":"section"},{"location":"solution_interface/","page":"Solution interface","title":"Solution interface","text":"ProfileLikelihoodSolution type is designed to contain the results of a profile likelihood analysis.","category":"page"},{"location":"solution_interface/#LikelihoodProfiler.ProfileLikelihoodSolution-solution_interface","page":"Solution interface","title":"LikelihoodProfiler.ProfileLikelihoodSolution","text":"ProfileLikelihoodSolution{probType,P}\n\nContains the results of a profile likelihood analysis.\n\nFields\n\nprob::probType: The profile likelihood problem ProfileLikelihoodProblem.\nprofiles::P: The computed profile curves.\nelapsed_time::Float64: The time elapsed during the computation.\n\nSelectors\n\nA number of selectors are available to extract information from the sol::ProfileLikelihoodSolution object. These can be applied to each computed profile sol[i]:\n\nendpoints(sol[i]): Returns the confidence interval (CI) endpoints, marking the intersection of the profile with the threshold.\nretcodes(sol[i]): Returns the retcodes of the CI endpoints estimation.\nstats(sol[i]): Returns the statistics of the profile computation.\n\n\n\n\n\n","category":"type"},{"location":"solution_interface/#Retcodes","page":"Solution interface","title":"Retcodes","text":"","category":"section"},{"location":"solution_interface/","page":"Solution interface","title":"Solution interface","text":"sol::ProfileLikelihoodSolution outputs the following retcodes, which are accessible with retcodes(sol[i]) function:","category":"page"},{"location":"solution_interface/","page":"Solution interface","title":"Solution interface","text":":Identifiable - the profile has intersection with the predefined threshold.\n:NonIdentifiable - the profile doesn't intersect the predefined threshold.\n:MaxIters - maximum number of iterations reached while computing the profile. See maxiters argument to the solve.\n:Failure - the solver (optimizer or integrator) reported failure status, profiling was interrupted. ","category":"page"},{"location":"solution_interface/#Endpoints-(confidence-interval-estimates)","page":"Solution interface","title":"Endpoints (confidence-interval estimates)","text":"","category":"section"},{"location":"solution_interface/","page":"Solution interface","title":"Solution interface","text":"endpoints(sol[i]) returns the estimated crossing points of the profile with the chosen likelihood threshold for the i-th profile. ","category":"page"},{"location":"solution_interface/#Visualization-and-tabular-representation","page":"Solution interface","title":"Visualization and tabular representation","text":"","category":"section"},{"location":"solution_interface/","page":"Solution interface","title":"Solution interface","text":"The recipes are defined to visualize profiles saved in sol::ProfileLikelihoodSolution with Plots.jl package: plot(sol), plot(sol[i]).  The following keyword arguments can be used in plot function:","category":"page"},{"location":"solution_interface/","page":"Solution interface","title":"Solution interface","text":"steps::Bool - whether to scatter steps performed by the profiler. Defaults to true.\nthreshold::Bool - whether to plot threshold defined in ProfileLikelihoodProblem. Defaults to isfinite(threshold)","category":"page"},{"location":"solution_interface/","page":"Solution interface","title":"Solution interface","text":"Also each profile contained in the sol::ProfileLikelihoodSolution can be represented as a DataFrame with DataFrame(sol[i]).","category":"page"},{"location":"case_studies/taxol/#Taxol-model","page":"Taxol model","title":"Taxol model","text":"","category":"section"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"As an example of practical identifiability analysis, we use the Cancer Taxol Treatment Model. It is an ODE model with 3 state variables and 5 parameters. The identifiability of this model was studied in Marisa C.Eisenberg, Harsh V.Jain. A confidence building exercise in data and identifiability. We have translated author's MATLAB code into Julia. The model is defined by the following system of differential equations:","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"using LikelihoodProfiler, Test\nusing Optimization, ForwardDiff, OrdinaryDiffEq\n\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_de.m\nfunction ode_func(du, u, p, t, drug)\n  let (a0, ka, r0, d0, kd) = (p[1], p[2], p[3], p[4], p[5])\n\n      K   = 10.515*100\n      V0  = 1.3907*K\n      lam = 9.5722\n\n      theta = 10.\n\n      # Values taken from \n      aRP  = 20.     # per day from Kim_PrlifQuies\n\n      Ncel = u[1] + u[2] + u[3]\n      Lfac = ((K-Ncel)^theta)/((V0^theta) + ((K-Ncel)^theta))\n\n      arstexp = 3.\n      adthexp = 4.\n\n      arst = a0*(drug^arstexp)/(ka^arstexp + (drug^arstexp))\n      adth = d0*(drug^adthexp)/(kd^adthexp + (drug^adthexp))\n      arcv = r0\n\n      # The differntial equations\n      du[1] = -lam*u[1] + aRP*u[2]*Lfac - arst*u[1] + arcv*u[3]\n      du[2] = 2*lam*u[1] - aRP*u[2]*Lfac\n      du[3] = arst*u[1] - adth*u[3] - arcv*u[3]\n  end\nend","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"Experimental datasets are also provided in the cancer-chemo-identifiability repo for four drug doses (5, 10, 40, 100)","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_fit.m\n\n# Data from Terzis et al. Brit J Cancer 1997;75:1744.\n# From Bowman et al. Glia 1999;27:22, glioma cell volume is 0.916\n# picoliters, 1 mm^3 = 1e6 pl or ~1.091 million cells\n\ntimes = [0., 3., 6., 9., 12., 15.]   # days\n\ndose = [5., 10., 40., 100.];    # dose in ng/ml\n\n# Control data\nCell = [0.009, 0.050, 0.120, 0.189, 0.230, 0.260]*1091.0   # thousands of cells\nCerr = [0.006, 0.012, 0.010, 0.011, 0.011, 0.011]*1091.0   # thousands of cells\n\n# 0.005 ug/ml Taxol\nCell005 = [0.009, 0.047, 0.089, 0.149, 0.198, 0.219]*1091.0   # thousands of cells\nCerr005 = [0.006, 0.013, 0.010, 0.011, 0.013, 0.010]*1091.0   # thousands of cells\n\n# 0.010 ug/ml Taxol\nCell010 = [0.009, 0.043, 0.077, 0.093, 0.109, 0.128]*1091.0   # thousands of cells\nCerr010 = [0.006, 0.012, 0.013, 0.012, 0.014, 0.012]*1091.0   # thousands of cells\n\n# 0.040 ug/ml Taxol\nCell040 = [0.009, 0.025, 0.047, 0.054, 0.076, 0.085]*1091.0   # thousands of cells\nCerr040 = [0.005, 0.010, 0.010, 0.011, 0.010, 0.010]*1091.0   # thousands of cells\n\n# 0.100 ug/ml Taxol\nCell100 = [0.009, 0.025, 0.026, 0.028, 0.029, 0.031]*1091.0   # thousands of cells\nCerr100 = [0.006, 0.010, 0.009, 0.008, 0.011, 0.011]*1091.0   # thousands of cells\n\nC005 = LikelihoodProfiler.mean(Cell005)\nC010 = LikelihoodProfiler.mean(Cell010)\nC040 = LikelihoodProfiler.mean(Cell040)\nC100 = LikelihoodProfiler.mean(Cell100)\n\ndata = [Cell005/C005, Cell010/C010, Cell040/C040, Cell100/C100]\ndatamean = [C005, C010, C040, C100]","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"Next we define solver options, initial values, optimal parameter values, and tspan","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"# solver algorithm and tolerances\nsolver_opts = Dict(\n    :alg => AutoTsit5(Rosenbrock23()),\n    :reltol => 1e-6,\n    :abstol => 1e-8\n)\n\n# initial values and parameters\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_soln.m#L3-L6\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_fit.m#L4\n\nu0 = [7.2700, 2.5490, 0.]\np0 = [8.3170, 8.0959, 0.0582, 1.3307, 119.1363] \n\ntspan = (0.,15.)","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"We use OLS for the objective function as proposed in the original code.","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_fit.m#L92\n# https://www.mathworks.com/help/optim/ug/lsqcurvefit.html\nfunction taxol_obj(\n  x, _p;\n  ode_func=ode_func,\n  dose=dose,\n  data=data,\n  datamean=datamean,\n  times=times,\n  solver_opts=solver_opts\n)\n  loss = 0.\n  for (i,d) in enumerate(dose)\n     prob = ODEProblem((du,u,p,t)->ode_func(du,u,p,t,d), u0, tspan, x)\n     sol = solve(prob, \n                 solver_opts[:alg], \n                 reltol=solver_opts[:reltol],\n                 abstol=solver_opts[:abstol],\n                 saveat=times)\n      \n     sim = (sol[1,:] + sol[2,:] + sol[3,:])/datamean[i]\n     loss += sum((sim-data[i]).^2)\n  end\n  return loss\nend\n\n# threshold is chosen according to\n# https://github.com/marisae/cancer-chemo-identifiability/blob/master/Profile%20Likelihood/testa0_fit.m#L40-L41\nsigmasq = (LikelihoodProfiler.mean([(Cerr005/C005); (Cerr010/C010); (Cerr040/C040); (Cerr100/C100)]))^2","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"Next, we construct the profile likelihood problem ProfileLikelihoodProblem and run the profiler for the five parameters:","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"lb = [2.0, 2.0, 0.01, 0.05, 30.]\nub = [30.0, 30.0, 0.6, 5.0, 250.0]\n\noptf = OptimizationFunction(taxol_obj, Optimization.AutoForwardDiff())\noptprob = OptimizationProblem(optf, p0; lb=lb, ub=ub)\n\nplprob = ProfileLikelihoodProblem(optprob, p0; threshold = sigmasq*chi2_quantile(0.95, 5))\n\nprofile_step(p0, i) = p0[i] * 0.1\nmethod = OptimizationProfiler(optimizer = Optimization.LBFGS(), stepper = FixedStep(; initial_step=profile_step))\nsol = solve(plprob, method)\nplot(sol, size=(800,300), margins=5Plots.mm)","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"Finally, we plot the resulting profiles:","category":"page"},{"location":"case_studies/taxol/","page":"Taxol model","title":"Taxol model","text":"(Image: taxol.png)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LikelihoodProfiler is a Julia package for practical identifiability analysis and confidence intervals estimation using the profile likelihood approach. The package provides a unified interface for various profile likelihood-based methods of practical identifiability: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Confidence intervals by Constrained Optimization method (CICO)\nOptimization-based likelihood profiles\nIntegration-based likelihood profiles\nHybrid approaches","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Julia terminal run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"LikelihoodProfiler\")","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Borisov I., Metelkin E. An Algorithm for Practical Identifiability Analysis and Confidence Intervals Evaluation Based on Constrained Optimization. 2018. October. ICSB2018. https://doi.org/10.13140/RG.2.2.18935.06563","category":"page"},{"location":"problem_interface/#Defining-a-ProfileLikelihoodProblem","page":"Problem interface","title":"Defining a ProfileLikelihoodProblem","text":"","category":"section"},{"location":"problem_interface/","page":"Problem interface","title":"Problem interface","text":"ProfileLikelihoodProblem type is designed to contain the necessary information to define a profile likelihood problem.","category":"page"},{"location":"problem_interface/#LikelihoodProfiler.ProfileLikelihoodProblem-problem_interface","page":"Problem interface","title":"LikelihoodProfiler.ProfileLikelihoodProblem","text":"ProfileLikelihoodProblem{T,probType,P}\n\nDefines a profile likelihood problem.\n\nMathematical Specification of a Profile Likelihood Problem:\n\nA problem is specified by:\n\noptprob::OptimizationProblem — wraps your objective (e.g. negative log-likelihood)\noptpars::AbstractVector{<:Real} — parameter values to start profiling from (typically the optimum)\ntarget::AbstractProfileTarget — what to profile (parameters or functions)\n\nConstructors\n\nExplicit target interface (advanced)\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real}, target::AbstractProfileTarget; \n  conf_level::Float64 = 0.95, df::Int = 1, threshold::Union{Nothing,Real} = nothing)\n\ntarget: ParameterTarget (see ParameterTarget) or FunctionTarget (see FunctionTarget) defining what to profile and the profile bounds.\nconf_level: Confidence level for the profile likelihood. Defaults to 0.95.\ndf: Degrees of freedom for the profile likelihood. Defaults to 1.\nthreshold: Profile likelihood threshold. If not provided, computed from conf_level and df. Can be set to Inf if confidence interval endpoint estimation is not required.\n\nParameter profiling sugar\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real};\n  idxs = nothing, profile_lower = nothing, profile_upper = nothing, kwargs...)\n\nidxs: Indices of parameters to profile; Integer or vector of integers; if nothing, profile all parameters.\nprofile_lower, profile_upper: Bounds for profiling. Accept scalars or vectors of finite numbers; if nothing, taken from optprob. If scalar bounds are provided, they will be expanded to match the number of parameters being profiled.\nkwargs...: passed to the explicit target constructor.\n\nFunction profiling sugar\n\nProfileLikelihoodProblem(optprob::OptimizationProblem, optpars::AbstractVector{<:Real};\n  fs = nothing, profile_lower = nothing, profile_upper = nothing, kwargs...)\n\nfs: OptimizationFunction or vector of OptimizationFunction - functions of parameters to be profiled.\n\nprofile_lower, profile_upper: Bounds for profiling. Accept scalars or vectors of finite numbers. If scalar bounds are provided, they will be expanded to match the number of functions being profiled.\nkwargs...: passed to the explicit target constructor.\n\n\n\n\n\n","category":"type"},{"location":"problem_interface/#Targets-(what-you-profile)","page":"Problem interface","title":"Targets (what you profile)","text":"","category":"section"},{"location":"problem_interface/","page":"Problem interface","title":"Problem interface","text":"A profile target specifies the quantity whose profile you want: either one or more parameters by index, or one or more functions of the parameters. Targets carry their own profile bounds (profile_lower, profile_upper) which delimit where each profile is traced.","category":"page"},{"location":"problem_interface/#ParameterTarget","page":"Problem interface","title":"ParameterTarget","text":"","category":"section"},{"location":"problem_interface/","page":"Problem interface","title":"Problem interface","text":"ParameterTarget profiles model parameters by index.  While you can build ParameterTarget directly, most users prefer the convenience constructor on ProfileLikelihoodProblem, which accepts idxs and bounds and constructs the target for you. See ProfileLikelihoodProblem interface.","category":"page"},{"location":"problem_interface/#LikelihoodProfiler.ParameterTarget-problem_interface","page":"Problem interface","title":"LikelihoodProfiler.ParameterTarget","text":"ParameterTarget{I,B}\n\nProfile target representing profiling of model parameters.\n\nFields\n\nidxs::AbstractVector{<:Integer}: Indices of the parameters being profiled.\nprofile_lower::AbstractVector{<:Real}: Lower bounds for the profile likelihood. \nprofile_upper::AbstractVector{<:Real}: Upper bounds for the profile likelihood. \n\nProfile bounds profile_lower and profile_upper should be vectors of finite numerical values. \n\nConstructors\n\nCreate a target with explicit lower and upper bounds for each index.\n\nParameterTarget(; idxs::AbstractVector{<:Integer}, profile_lower::AbstractVector{<:Real}, profile_upper::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"problem_interface/#Explicit-construction-example","page":"Problem interface","title":"Explicit construction example","text":"","category":"section"},{"location":"problem_interface/","page":"Problem interface","title":"Problem interface","text":"using LikelihoodProfiler, Optimization\n\nf = OptimizationFunction((θ,p)->sum(abs2, θ))\noptprob = OptimizationProblem(f, [1.0, 2.0, 3.0])\n\npt = ParameterTarget(; idxs=[1,3],\n                     profile_lower=[-5.0, -1.0],\n                     profile_upper=[ 2.0,  4.0])\n\nplprob = ProfileLikelihoodProblem(optprob, [0.0, 0.0, 0.0], pt;\n                                  conf_level=0.95)  # threshold derived from χ²","category":"page"},{"location":"problem_interface/#FunctionTarget","page":"Problem interface","title":"FunctionTarget","text":"","category":"section"},{"location":"problem_interface/","page":"Problem interface","title":"Problem interface","text":"FunctionTarget profiles functions of the parameters. While you can build FunctionTarget directly, most users prefer the convenience constructor on ProfileLikelihoodProblem, which accepts functions and bounds and constructs the target for you. See ProfileLikelihoodProblem interface.","category":"page"},{"location":"problem_interface/#LikelihoodProfiler.FunctionTarget-problem_interface","page":"Problem interface","title":"LikelihoodProfiler.FunctionTarget","text":"FunctionTarget{F,B}\n\nProfile target representing profiling of functions of model parameters.\n\nFields\n\nfs::AbstractVector{<:OptimizationFunction}: Functions of the parameters being profiled.\nprofile_lower::AbstractVector{<:Real}: Lower bounds for the profile likelihood. \nprofile_upper::AbstractVector{<:Real}: Upper bounds for the profile likelihood. \n\nProfile bounds profile_lower and profile_upper should be vectors of finite numerical values. \n\nConstructors\n\nCreate a target with explicit lower and upper bounds for each function of parameters.\n\nFunctionTarget(; fs::AbstractVector{<:OptimizationFunction}, profile_lower::AbstractVector{<:Real}, profile_upper::AbstractVector{<:Real})\n\n\n\n\n\n","category":"type"},{"location":"problem_interface/#Explicit-construction-example-2","page":"Problem interface","title":"Explicit construction example","text":"","category":"section"},{"location":"problem_interface/","page":"Problem interface","title":"Problem interface","text":"using LikelihoodProfiler, Optimization\n\nf = OptimizationFunction((θ,p)->sum(abs2, θ))\noptprob = OptimizationProblem(f, [1.0, 2.0, 3.0])\n\ng1 = OptimizationFunction((θ,p)->θ[1] + θ[2])\ng2 = OptimizationFunction((θ,p)->θ[2] - θ[3])\n\nft = FunctionTarget(; fs=[g1,g2],\n                    profile_lower=[-2.0, -1.0],\n                    profile_upper=[ 2.0,  1.0])\n\nplprob = ProfileLikelihoodProblem(optprob, [0.0, 0.0, 0.0], ft)","category":"page"},{"location":"problem_interface/#Problem-“sugar”-constructors","page":"Problem interface","title":"Problem “sugar” constructors","text":"","category":"section"},{"location":"problem_interface/","page":"Problem interface","title":"Problem interface","text":"For ergonomics, ProfileLikelihoodProblem provides keyword constructors that build the target for you.","category":"page"},{"location":"problem_interface/","page":"Problem interface","title":"Problem interface","text":"ProfileLikelihoodProblem(::OptimizationProblem, ::AbstractVector{<:Real}; idxs, profile_lower, profile_upper)\nProfileLikelihoodProblem(::OptimizationProblem, ::AbstractVector{<:Real}, ::Union{OptimizationFunction,AbstractVector{<:OptimizationFunction}}; profile_lower, profile_upper)","category":"page"},{"location":"tutorial/#Getting-started-with-LikelihoodProfiler","page":"Tutorial","title":"Getting started with LikelihoodProfiler","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To define a profile likelihood problem ProfileLikelihoodProblem in LikelihoodProfiler, you should provide the objective function (usually negative log likelihood) and the optimal values of the parameters that correspond to the minimum of the objective function. LikelihoodProfiler relies on the Optimization.jl interface, and ProfileLikelihoodProblem is built on top of the OptimizationProblem defined in Optimization.jl. This can be best illustrated by an example.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First we define the OptimizationProblem and solve it with the preferred optimizer to obtain the optimal values of the parameters. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Optimization, ForwardDiff\n\n# objective function\nrosenbrock(x,p) = (1.0 - x[1])^2 + 100.0*(x[2] - x[1]^2)^2\n\n# initial values\nx0 = zeros(2)\n\n# solving optimization problem\noptf = OptimizationFunction(rosenbrock, AutoForwardDiff())\noptprob = OptimizationProblem(optf, x0)\nsol = solve(optprob, Optimization.LBFGS())","category":"page"},{"location":"tutorial/#Profile-likelihood-problem-interface","page":"Tutorial","title":"Profile likelihood problem interface","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To define the ProfileLikelihoodProblem, we need the OptimizationProblem and the optimal values of the parameters. We can also set the profiling domain with the profile_lower, profile_upper arguments, indicies of parameters to profile with idxs and the threshold, which is the confidence level required to estimate confidence intervals. Please consult ?ProfileLikelihoodProblem on the details of the interface.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LikelihoodProfiler, Plots\n\n# optimal values of the parameters\noptpars = sol.u\n\n# profile likelihood problem\nplprob = ProfileLikelihoodProblem(optprob, optpars; profile_lower = -10., profile_upper=10., threshold = 4.0)","category":"page"},{"location":"tutorial/#Profile-likelihood-methods","page":"Tutorial","title":"Profile likelihood methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"LikelihoodProfiler provides a range of methods to profile likelihood functions and explore practical identifiability. The most common and simple \"profiler\" is the OptimizationProfiler method. It is based on stepwise re-optimization of the likelihood function with the constraint on the parameter (or function) of interest. We define the method and run the solve procedure. Please consult ?solve on the details of the interface.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = OptimizationProfiler(optimizer = Optimization.LBFGS(), stepper = FixedStep(; initial_step=0.15))\nsol = solve(plprob, method)\nplot(sol, size=(800,300), margins=5Plots.mm)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The same solve interface can be used with other profiling methods. For example, a more advanced way to compute profiles is proposed by IntegrationProfiler. It obtains the profiles as solutions to the differential equation system. To solve this internally generated system, we need to provide a differential equations solver (integrator).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using OrdinaryDiffEq\n\nmethod = IntegrationProfiler(integrator = Tsit5(), integrator_opts = (dtmax=0.3,), matrix_type = :hessian)\nsol = solve(plprob, method)\nplot(sol, size=(800,300), margins=5Plots.mm)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Likelihood profiling is mostly performed to assess if the profile has intersections with the given confidence level, hence if the parameter (or function of parameters) has finite confidence interval. Another approach to the problem of practical identifiability is to compute these intersections (endpoints of the confidence interval (CI)) without restoring the full shape of the profile. One of such methods is implemented in CICOProfiler. It estimates CI endpoints with an optimization procedure without following the exact trajectory of the profile. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CICOBase\n\nmethod = CICOProfiler(optimizer = :LN_NELDERMEAD, scan_tol = 1e-4)\nsol = solve(plprob, method)\nplot(sol, size=(800,300), margins=5Plots.mm)","category":"page"}]
}
